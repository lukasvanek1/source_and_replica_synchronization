import argparse # handling comand line arguments, getting users' input
import os  # file and directory ops
import logging # handling files- copy, delete...
import shutil  # files and dir copying
import hashlib  # MD5 checksums generating
import time  # adding delays between synchronization runs
from datetime import datetime  # adding timestamps to reports
import sys # needed for graceful exit
import signal # signal interruption handling



# argument parsing for handling files
def parse_arguments():
    parser = argparse.ArgumentParser(description="Sync source and replica folders")
    parser.add_argument('source', help="Source folder path")
    parser.add_argument('replica', help="Replica folder path")
    parser.add_argument('interval', type=int, help="Sync interval in seconds")
    parser.add_argument('logfile', help="Log file path")
    parser.add_argument('--dry-run', action='store_true', help="Perform a trial run with no changes made")
    return parser.parse_args()

# logging operations @ file&console
def setup_logging(logfile):
    logging.basicConfig(
        filename=logfile,
        level=logging.INFO,
        format='%(asctime)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
        filemode='a'
    )
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    formatter = logging.Formatter('%(asctime)s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
    console_handler.setFormatter(formatter)
    logging.getLogger().addHandler(console_handler)

#  MD5 checksum of a file calculation
def calculate_md5(file_path, block_size=8192):
    md5 = hashlib.md5()
    with open(file_path, "rb") as f:
        for chunk in iter(lambda: f.read(block_size), b""):
            md5.update(chunk)
    return md5.hexdigest()

# synchronizing the source & replica folders
def sync_folders(source, replica, dry_run=False):
    total_operations = sum((len(files) for _, _, files in os.walk(source)))
    completed_operations = 0

    if not os.path.exists(replica) and not dry_run:
        os.makedirs(replica)
        logging.info(f"Replica folder created: {replica}")

    for dirpath, dirnames, filenames in os.walk(source):
        rel_path = os.path.relpath(dirpath, source)
        replica_dirpath = os.path.join(replica, rel_path)

        if not os.path.exists(replica_dirpath) and not dry_run:
            os.makedirs(replica_dirpath)
            logging.info(f"Directory created: {replica_dirpath}")

        for filename in filenames:
            source_file = os.path.join(dirpath, filename)
            replica_file = os.path.join(replica_dirpath, filename)

            if not os.path.exists(replica_file) or calculate_md5(source_file) != calculate_md5(replica_file):
                if not dry_run:
                    try:
                        shutil.copy2(source_file, replica_file)
                        logging.info(f"File {'updated' if os.path.exists(replica_file) else 'copied'}: {source_file} -> {replica_file}")
                    except (PermissionError, FileNotFoundError) as e:
                        logging.error(f"Error copying {source_file}: {str(e)}")

            completed_operations += 1
            progress = (completed_operations / total_operations) * 100
            print(f"\rProgress: {progress:.2f}%", end="")

    print()  # New line after progress bar

    for dirpath, dirnames, filenames in os.walk(replica):
        rel_path = os.path.relpath(dirpath, replica)
        source_dirpath = os.path.join(source, rel_path)

        for filename in filenames:
            replica_file = os.path.join(dirpath, filename)
            source_file = os.path.join(source_dirpath, filename)
            if not os.path.exists(source_file):
                if not dry_run:
                    try:
                        os.remove(replica_file)
                        logging.info(f"File removed: {replica_file}")
                    except PermissionError:
                        logging.error(f"Permission denied: Unable to remove {replica_file}")

        for dirname in dirnames:
            replica_dir = os.path.join(dirpath, dirname)
            source_dir = os.path.join(source_dirpath, dirname)
            if not os.path.exists(source_dir):
                if not dry_run:
                    try:
                        shutil.rmtree(replica_dir)
                        logging.info(f"Directory removed: {replica_dir}")
                    except PermissionError:
                        logging.error(f"Permission denied: Unable to remove directory {replica_dir}")

# graceful exit
def signal_handler(signum, frame):
    logging.info("Received interrupt signal. Exiting gracefully...")
    sys.exit(0)

# periodic sync main loop
def main():
    args = parse_arguments()

    # paths validation
    if not os.path.exists(args.source):
        print(f"Error: Source path '{args.source}' does not exist.")
        return
    if not os.path.exists(os.path.dirname(args.logfile)):
        print(f"Error: Log file directory '{os.path.dirname(args.logfile)}' does not exist.")
        return

    setup_logging(args.logfile)

